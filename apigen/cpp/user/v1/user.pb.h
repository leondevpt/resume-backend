// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user/v1/user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_2fv1_2fuser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_2fv1_2fuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_2fv1_2fuser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2fv1_2fuser_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_2fv1_2fuser_2eproto;
namespace resume {
namespace user {
namespace v1 {
class GenericResponse;
struct GenericResponseDefaultTypeInternal;
extern GenericResponseDefaultTypeInternal _GenericResponse_default_instance_;
class GetMeRequest;
struct GetMeRequestDefaultTypeInternal;
extern GetMeRequestDefaultTypeInternal _GetMeRequest_default_instance_;
class SignInUserInput;
struct SignInUserInputDefaultTypeInternal;
extern SignInUserInputDefaultTypeInternal _SignInUserInput_default_instance_;
class SignInUserResponse;
struct SignInUserResponseDefaultTypeInternal;
extern SignInUserResponseDefaultTypeInternal _SignInUserResponse_default_instance_;
class SignUpUserInput;
struct SignUpUserInputDefaultTypeInternal;
extern SignUpUserInputDefaultTypeInternal _SignUpUserInput_default_instance_;
class SignUpUserResponse;
struct SignUpUserResponseDefaultTypeInternal;
extern SignUpUserResponseDefaultTypeInternal _SignUpUserResponse_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserResponse;
struct UserResponseDefaultTypeInternal;
extern UserResponseDefaultTypeInternal _UserResponse_default_instance_;
class VerifyEmailRequest;
struct VerifyEmailRequestDefaultTypeInternal;
extern VerifyEmailRequestDefaultTypeInternal _VerifyEmailRequest_default_instance_;
}  // namespace v1
}  // namespace user
}  // namespace resume
PROTOBUF_NAMESPACE_OPEN
template<> ::resume::user::v1::GenericResponse* Arena::CreateMaybeMessage<::resume::user::v1::GenericResponse>(Arena*);
template<> ::resume::user::v1::GetMeRequest* Arena::CreateMaybeMessage<::resume::user::v1::GetMeRequest>(Arena*);
template<> ::resume::user::v1::SignInUserInput* Arena::CreateMaybeMessage<::resume::user::v1::SignInUserInput>(Arena*);
template<> ::resume::user::v1::SignInUserResponse* Arena::CreateMaybeMessage<::resume::user::v1::SignInUserResponse>(Arena*);
template<> ::resume::user::v1::SignUpUserInput* Arena::CreateMaybeMessage<::resume::user::v1::SignUpUserInput>(Arena*);
template<> ::resume::user::v1::SignUpUserResponse* Arena::CreateMaybeMessage<::resume::user::v1::SignUpUserResponse>(Arena*);
template<> ::resume::user::v1::User* Arena::CreateMaybeMessage<::resume::user::v1::User>(Arena*);
template<> ::resume::user::v1::UserResponse* Arena::CreateMaybeMessage<::resume::user::v1::UserResponse>(Arena*);
template<> ::resume::user::v1::VerifyEmailRequest* Arena::CreateMaybeMessage<::resume::user::v1::VerifyEmailRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace resume {
namespace user {
namespace v1 {

enum User_role : int {
  User_role_user = 0,
  User_role_admin = 1,
  User_role_User_role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  User_role_User_role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool User_role_IsValid(int value);
constexpr User_role User_role_role_MIN = User_role_user;
constexpr User_role User_role_role_MAX = User_role_admin;
constexpr int User_role_role_ARRAYSIZE = User_role_role_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* User_role_descriptor();
template<typename T>
inline const std::string& User_role_Name(T enum_t_value) {
  static_assert(::std::is_same<T, User_role>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function User_role_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    User_role_descriptor(), enum_t_value);
}
inline bool User_role_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, User_role* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<User_role>(
    User_role_descriptor(), name, value);
}
// ===================================================================

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef User_role role;
  static constexpr role user =
    User_role_user;
  static constexpr role admin =
    User_role_admin;
  static inline bool role_IsValid(int value) {
    return User_role_IsValid(value);
  }
  static constexpr role role_MIN =
    User_role_role_MIN;
  static constexpr role role_MAX =
    User_role_role_MAX;
  static constexpr int role_ARRAYSIZE =
    User_role_role_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  role_descriptor() {
    return User_role_descriptor();
  }
  template<typename T>
  static inline const std::string& role_Name(T enum_t_value) {
    static_assert(::std::is_same<T, role>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function role_Name.");
    return User_role_Name(enum_t_value);
  }
  static inline bool role_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      role* value) {
    return User_role_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kEmailFieldNumber = 3,
    kCreatedAtFieldNumber = 4,
    kUpdatedAtFieldNumber = 5,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string email = 3 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .google.protobuf.Timestamp created_at = 4 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 5 [json_name = "updatedAt"];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // @@protoc_insertion_point(class_scope:resume.user.v1.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class UserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.UserResponse) */ {
 public:
  inline UserResponse() : UserResponse(nullptr) {}
  ~UserResponse() override;
  explicit PROTOBUF_CONSTEXPR UserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserResponse(const UserResponse& from);
  UserResponse(UserResponse&& from) noexcept
    : UserResponse() {
    *this = ::std::move(from);
  }

  inline UserResponse& operator=(const UserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserResponse& operator=(UserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserResponse* internal_default_instance() {
    return reinterpret_cast<const UserResponse*>(
               &_UserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserResponse& a, UserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserResponse& from) {
    UserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.UserResponse";
  }
  protected:
  explicit UserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .resume.user.v1.User user = 1 [json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::resume::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::resume::user::v1::User* release_user();
  ::resume::user::v1::User* mutable_user();
  void set_allocated_user(::resume::user::v1::User* user);
  private:
  const ::resume::user::v1::User& _internal_user() const;
  ::resume::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::resume::user::v1::User* user);
  ::resume::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:resume.user.v1.UserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::resume::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GenericResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.GenericResponse) */ {
 public:
  inline GenericResponse() : GenericResponse(nullptr) {}
  ~GenericResponse() override;
  explicit PROTOBUF_CONSTEXPR GenericResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericResponse(const GenericResponse& from);
  GenericResponse(GenericResponse&& from) noexcept
    : GenericResponse() {
    *this = ::std::move(from);
  }

  inline GenericResponse& operator=(const GenericResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericResponse& operator=(GenericResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericResponse* internal_default_instance() {
    return reinterpret_cast<const GenericResponse*>(
               &_GenericResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GenericResponse& a, GenericResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenericResponse& from) {
    GenericResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.GenericResponse";
  }
  protected:
  explicit GenericResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:resume.user.v1.GenericResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class SignUpUserInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.SignUpUserInput) */ {
 public:
  inline SignUpUserInput() : SignUpUserInput(nullptr) {}
  ~SignUpUserInput() override;
  explicit PROTOBUF_CONSTEXPR SignUpUserInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignUpUserInput(const SignUpUserInput& from);
  SignUpUserInput(SignUpUserInput&& from) noexcept
    : SignUpUserInput() {
    *this = ::std::move(from);
  }

  inline SignUpUserInput& operator=(const SignUpUserInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignUpUserInput& operator=(SignUpUserInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignUpUserInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignUpUserInput* internal_default_instance() {
    return reinterpret_cast<const SignUpUserInput*>(
               &_SignUpUserInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SignUpUserInput& a, SignUpUserInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SignUpUserInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignUpUserInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignUpUserInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignUpUserInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignUpUserInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignUpUserInput& from) {
    SignUpUserInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignUpUserInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.SignUpUserInput";
  }
  protected:
  explicit SignUpUserInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEmailFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kPasswordConfirmFieldNumber = 4,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 3 [json_name = "password"];
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string passwordConfirm = 4 [json_name = "passwordConfirm"];
  void clear_passwordconfirm();
  const std::string& passwordconfirm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwordconfirm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwordconfirm();
  PROTOBUF_NODISCARD std::string* release_passwordconfirm();
  void set_allocated_passwordconfirm(std::string* passwordconfirm);
  private:
  const std::string& _internal_passwordconfirm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwordconfirm(const std::string& value);
  std::string* _internal_mutable_passwordconfirm();
  public:

  // @@protoc_insertion_point(class_scope:resume.user.v1.SignUpUserInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwordconfirm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class SignUpUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.SignUpUserResponse) */ {
 public:
  inline SignUpUserResponse() : SignUpUserResponse(nullptr) {}
  ~SignUpUserResponse() override;
  explicit PROTOBUF_CONSTEXPR SignUpUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignUpUserResponse(const SignUpUserResponse& from);
  SignUpUserResponse(SignUpUserResponse&& from) noexcept
    : SignUpUserResponse() {
    *this = ::std::move(from);
  }

  inline SignUpUserResponse& operator=(const SignUpUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignUpUserResponse& operator=(SignUpUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignUpUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignUpUserResponse* internal_default_instance() {
    return reinterpret_cast<const SignUpUserResponse*>(
               &_SignUpUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SignUpUserResponse& a, SignUpUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignUpUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignUpUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignUpUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignUpUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignUpUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignUpUserResponse& from) {
    SignUpUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignUpUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.SignUpUserResponse";
  }
  protected:
  explicit SignUpUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .resume.user.v1.User user = 1 [json_name = "user"];
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::resume::user::v1::User& user() const;
  PROTOBUF_NODISCARD ::resume::user::v1::User* release_user();
  ::resume::user::v1::User* mutable_user();
  void set_allocated_user(::resume::user::v1::User* user);
  private:
  const ::resume::user::v1::User& _internal_user() const;
  ::resume::user::v1::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::resume::user::v1::User* user);
  ::resume::user::v1::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:resume.user.v1.SignUpUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::resume::user::v1::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class SignInUserInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.SignInUserInput) */ {
 public:
  inline SignInUserInput() : SignInUserInput(nullptr) {}
  ~SignInUserInput() override;
  explicit PROTOBUF_CONSTEXPR SignInUserInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignInUserInput(const SignInUserInput& from);
  SignInUserInput(SignInUserInput&& from) noexcept
    : SignInUserInput() {
    *this = ::std::move(from);
  }

  inline SignInUserInput& operator=(const SignInUserInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignInUserInput& operator=(SignInUserInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignInUserInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignInUserInput* internal_default_instance() {
    return reinterpret_cast<const SignInUserInput*>(
               &_SignInUserInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SignInUserInput& a, SignInUserInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SignInUserInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignInUserInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignInUserInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignInUserInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignInUserInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignInUserInput& from) {
    SignInUserInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignInUserInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.SignInUserInput";
  }
  protected:
  explicit SignInUserInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string email = 1 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 2 [json_name = "password"];
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:resume.user.v1.SignInUserInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class SignInUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.SignInUserResponse) */ {
 public:
  inline SignInUserResponse() : SignInUserResponse(nullptr) {}
  ~SignInUserResponse() override;
  explicit PROTOBUF_CONSTEXPR SignInUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignInUserResponse(const SignInUserResponse& from);
  SignInUserResponse(SignInUserResponse&& from) noexcept
    : SignInUserResponse() {
    *this = ::std::move(from);
  }

  inline SignInUserResponse& operator=(const SignInUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignInUserResponse& operator=(SignInUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignInUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignInUserResponse* internal_default_instance() {
    return reinterpret_cast<const SignInUserResponse*>(
               &_SignInUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SignInUserResponse& a, SignInUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignInUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignInUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignInUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignInUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignInUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignInUserResponse& from) {
    SignInUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignInUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.SignInUserResponse";
  }
  protected:
  explicit SignInUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kAccessTokenFieldNumber = 2,
    kRefreshTokenFieldNumber = 3,
  };
  // string status = 1 [json_name = "status"];
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string access_token = 2 [json_name = "accessToken"];
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // string refresh_token = 3 [json_name = "refreshToken"];
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // @@protoc_insertion_point(class_scope:resume.user.v1.SignInUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class VerifyEmailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.VerifyEmailRequest) */ {
 public:
  inline VerifyEmailRequest() : VerifyEmailRequest(nullptr) {}
  ~VerifyEmailRequest() override;
  explicit PROTOBUF_CONSTEXPR VerifyEmailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyEmailRequest(const VerifyEmailRequest& from);
  VerifyEmailRequest(VerifyEmailRequest&& from) noexcept
    : VerifyEmailRequest() {
    *this = ::std::move(from);
  }

  inline VerifyEmailRequest& operator=(const VerifyEmailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyEmailRequest& operator=(VerifyEmailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyEmailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyEmailRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyEmailRequest*>(
               &_VerifyEmailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VerifyEmailRequest& a, VerifyEmailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyEmailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyEmailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyEmailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyEmailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyEmailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyEmailRequest& from) {
    VerifyEmailRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyEmailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.VerifyEmailRequest";
  }
  protected:
  explicit VerifyEmailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerificationCodeFieldNumber = 1,
  };
  // string verificationCode = 1 [json_name = "verificationCode"];
  void clear_verificationcode();
  const std::string& verificationcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verificationcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verificationcode();
  PROTOBUF_NODISCARD std::string* release_verificationcode();
  void set_allocated_verificationcode(std::string* verificationcode);
  private:
  const std::string& _internal_verificationcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verificationcode(const std::string& value);
  std::string* _internal_mutable_verificationcode();
  public:

  // @@protoc_insertion_point(class_scope:resume.user.v1.VerifyEmailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verificationcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class GetMeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:resume.user.v1.GetMeRequest) */ {
 public:
  inline GetMeRequest() : GetMeRequest(nullptr) {}
  ~GetMeRequest() override;
  explicit PROTOBUF_CONSTEXPR GetMeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMeRequest(const GetMeRequest& from);
  GetMeRequest(GetMeRequest&& from) noexcept
    : GetMeRequest() {
    *this = ::std::move(from);
  }

  inline GetMeRequest& operator=(const GetMeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMeRequest& operator=(GetMeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMeRequest* internal_default_instance() {
    return reinterpret_cast<const GetMeRequest*>(
               &_GetMeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetMeRequest& a, GetMeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMeRequest& from) {
    GetMeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "resume.user.v1.GetMeRequest";
  }
  protected:
  explicit GetMeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string Id = 1 [json_name = "Id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:resume.user.v1.GetMeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// string id = 1 [json_name = "id"];
inline void User::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:resume.user.v1.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.User.id)
}

// string name = 2 [json_name = "name"];
inline void User::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& User::name() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.User.name)
}
inline std::string* User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.User.name)
  return _s;
}
inline const std::string& User::_internal_name() const {
  return _impl_.name_.Get();
}
inline void User::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:resume.user.v1.User.name)
  return _impl_.name_.Release();
}
inline void User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.User.name)
}

// string email = 3 [json_name = "email"];
inline void User::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& User::email() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.User.email)
}
inline std::string* User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.User.email)
  return _s;
}
inline const std::string& User::_internal_email() const {
  return _impl_.email_.Get();
}
inline void User::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_email() {
  // @@protoc_insertion_point(field_release:resume.user.v1.User.email)
  return _impl_.email_.Release();
}
inline void User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.User.email)
}

// .google.protobuf.Timestamp created_at = 4 [json_name = "createdAt"];
inline bool User::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool User::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::created_at() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.User.created_at)
  return _internal_created_at();
}
inline void User::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resume.user.v1.User.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:resume.user.v1.User.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.User.created_at)
  return _msg;
}
inline void User::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.User.created_at)
}

// .google.protobuf.Timestamp updated_at = 5 [json_name = "updatedAt"];
inline bool User::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool User::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& User::updated_at() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.User.updated_at)
  return _internal_updated_at();
}
inline void User::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resume.user.v1.User.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:resume.user.v1.User.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* User::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.User.updated_at)
  return _msg;
}
inline void User::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.User.updated_at)
}

// -------------------------------------------------------------------

// UserResponse

// .resume.user.v1.User user = 1 [json_name = "user"];
inline bool UserResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool UserResponse::has_user() const {
  return _internal_has_user();
}
inline void UserResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::resume::user::v1::User& UserResponse::_internal_user() const {
  const ::resume::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::resume::user::v1::User&>(
      ::resume::user::v1::_User_default_instance_);
}
inline const ::resume::user::v1::User& UserResponse::user() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.UserResponse.user)
  return _internal_user();
}
inline void UserResponse::unsafe_arena_set_allocated_user(
    ::resume::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resume.user.v1.UserResponse.user)
}
inline ::resume::user::v1::User* UserResponse::release_user() {
  
  ::resume::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::resume::user::v1::User* UserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:resume.user.v1.UserResponse.user)
  
  ::resume::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::resume::user::v1::User* UserResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::resume::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::resume::user::v1::User* UserResponse::mutable_user() {
  ::resume::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.UserResponse.user)
  return _msg;
}
inline void UserResponse::set_allocated_user(::resume::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.UserResponse.user)
}

// -------------------------------------------------------------------

// GenericResponse

// string status = 1 [json_name = "status"];
inline void GenericResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& GenericResponse::status() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.GenericResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.GenericResponse.status)
}
inline std::string* GenericResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.GenericResponse.status)
  return _s;
}
inline const std::string& GenericResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void GenericResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericResponse::release_status() {
  // @@protoc_insertion_point(field_release:resume.user.v1.GenericResponse.status)
  return _impl_.status_.Release();
}
inline void GenericResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.GenericResponse.status)
}

// string message = 2 [json_name = "message"];
inline void GenericResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GenericResponse::message() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.GenericResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenericResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.GenericResponse.message)
}
inline std::string* GenericResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.GenericResponse.message)
  return _s;
}
inline const std::string& GenericResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GenericResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GenericResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GenericResponse::release_message() {
  // @@protoc_insertion_point(field_release:resume.user.v1.GenericResponse.message)
  return _impl_.message_.Release();
}
inline void GenericResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.GenericResponse.message)
}

// -------------------------------------------------------------------

// SignUpUserInput

// string name = 1 [json_name = "name"];
inline void SignUpUserInput::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SignUpUserInput::name() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignUpUserInput.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignUpUserInput::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignUpUserInput.name)
}
inline std::string* SignUpUserInput::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignUpUserInput.name)
  return _s;
}
inline const std::string& SignUpUserInput::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SignUpUserInput::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SignUpUserInput::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SignUpUserInput::release_name() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignUpUserInput.name)
  return _impl_.name_.Release();
}
inline void SignUpUserInput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignUpUserInput.name)
}

// string email = 2 [json_name = "email"];
inline void SignUpUserInput::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& SignUpUserInput::email() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignUpUserInput.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignUpUserInput::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignUpUserInput.email)
}
inline std::string* SignUpUserInput::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignUpUserInput.email)
  return _s;
}
inline const std::string& SignUpUserInput::_internal_email() const {
  return _impl_.email_.Get();
}
inline void SignUpUserInput::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* SignUpUserInput::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* SignUpUserInput::release_email() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignUpUserInput.email)
  return _impl_.email_.Release();
}
inline void SignUpUserInput::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignUpUserInput.email)
}

// string password = 3 [json_name = "password"];
inline void SignUpUserInput::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& SignUpUserInput::password() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignUpUserInput.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignUpUserInput::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignUpUserInput.password)
}
inline std::string* SignUpUserInput::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignUpUserInput.password)
  return _s;
}
inline const std::string& SignUpUserInput::_internal_password() const {
  return _impl_.password_.Get();
}
inline void SignUpUserInput::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* SignUpUserInput::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* SignUpUserInput::release_password() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignUpUserInput.password)
  return _impl_.password_.Release();
}
inline void SignUpUserInput::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignUpUserInput.password)
}

// string passwordConfirm = 4 [json_name = "passwordConfirm"];
inline void SignUpUserInput::clear_passwordconfirm() {
  _impl_.passwordconfirm_.ClearToEmpty();
}
inline const std::string& SignUpUserInput::passwordconfirm() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignUpUserInput.passwordConfirm)
  return _internal_passwordconfirm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignUpUserInput::set_passwordconfirm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwordconfirm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignUpUserInput.passwordConfirm)
}
inline std::string* SignUpUserInput::mutable_passwordconfirm() {
  std::string* _s = _internal_mutable_passwordconfirm();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignUpUserInput.passwordConfirm)
  return _s;
}
inline const std::string& SignUpUserInput::_internal_passwordconfirm() const {
  return _impl_.passwordconfirm_.Get();
}
inline void SignUpUserInput::_internal_set_passwordconfirm(const std::string& value) {
  
  _impl_.passwordconfirm_.Set(value, GetArenaForAllocation());
}
inline std::string* SignUpUserInput::_internal_mutable_passwordconfirm() {
  
  return _impl_.passwordconfirm_.Mutable(GetArenaForAllocation());
}
inline std::string* SignUpUserInput::release_passwordconfirm() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignUpUserInput.passwordConfirm)
  return _impl_.passwordconfirm_.Release();
}
inline void SignUpUserInput::set_allocated_passwordconfirm(std::string* passwordconfirm) {
  if (passwordconfirm != nullptr) {
    
  } else {
    
  }
  _impl_.passwordconfirm_.SetAllocated(passwordconfirm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwordconfirm_.IsDefault()) {
    _impl_.passwordconfirm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignUpUserInput.passwordConfirm)
}

// -------------------------------------------------------------------

// SignUpUserResponse

// .resume.user.v1.User user = 1 [json_name = "user"];
inline bool SignUpUserResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool SignUpUserResponse::has_user() const {
  return _internal_has_user();
}
inline void SignUpUserResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::resume::user::v1::User& SignUpUserResponse::_internal_user() const {
  const ::resume::user::v1::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::resume::user::v1::User&>(
      ::resume::user::v1::_User_default_instance_);
}
inline const ::resume::user::v1::User& SignUpUserResponse::user() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignUpUserResponse.user)
  return _internal_user();
}
inline void SignUpUserResponse::unsafe_arena_set_allocated_user(
    ::resume::user::v1::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:resume.user.v1.SignUpUserResponse.user)
}
inline ::resume::user::v1::User* SignUpUserResponse::release_user() {
  
  ::resume::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::resume::user::v1::User* SignUpUserResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignUpUserResponse.user)
  
  ::resume::user::v1::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::resume::user::v1::User* SignUpUserResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::resume::user::v1::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::resume::user::v1::User* SignUpUserResponse::mutable_user() {
  ::resume::user::v1::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignUpUserResponse.user)
  return _msg;
}
inline void SignUpUserResponse::set_allocated_user(::resume::user::v1::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignUpUserResponse.user)
}

// -------------------------------------------------------------------

// SignInUserInput

// string email = 1 [json_name = "email"];
inline void SignInUserInput::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& SignInUserInput::email() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignInUserInput.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignInUserInput::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignInUserInput.email)
}
inline std::string* SignInUserInput::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignInUserInput.email)
  return _s;
}
inline const std::string& SignInUserInput::_internal_email() const {
  return _impl_.email_.Get();
}
inline void SignInUserInput::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* SignInUserInput::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* SignInUserInput::release_email() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignInUserInput.email)
  return _impl_.email_.Release();
}
inline void SignInUserInput::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignInUserInput.email)
}

// string password = 2 [json_name = "password"];
inline void SignInUserInput::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& SignInUserInput::password() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignInUserInput.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignInUserInput::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignInUserInput.password)
}
inline std::string* SignInUserInput::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignInUserInput.password)
  return _s;
}
inline const std::string& SignInUserInput::_internal_password() const {
  return _impl_.password_.Get();
}
inline void SignInUserInput::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* SignInUserInput::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* SignInUserInput::release_password() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignInUserInput.password)
  return _impl_.password_.Release();
}
inline void SignInUserInput::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignInUserInput.password)
}

// -------------------------------------------------------------------

// SignInUserResponse

// string status = 1 [json_name = "status"];
inline void SignInUserResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& SignInUserResponse::status() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignInUserResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignInUserResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignInUserResponse.status)
}
inline std::string* SignInUserResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignInUserResponse.status)
  return _s;
}
inline const std::string& SignInUserResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void SignInUserResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* SignInUserResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* SignInUserResponse::release_status() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignInUserResponse.status)
  return _impl_.status_.Release();
}
inline void SignInUserResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignInUserResponse.status)
}

// string access_token = 2 [json_name = "accessToken"];
inline void SignInUserResponse::clear_access_token() {
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& SignInUserResponse::access_token() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignInUserResponse.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignInUserResponse::set_access_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignInUserResponse.access_token)
}
inline std::string* SignInUserResponse::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignInUserResponse.access_token)
  return _s;
}
inline const std::string& SignInUserResponse::_internal_access_token() const {
  return _impl_.access_token_.Get();
}
inline void SignInUserResponse::_internal_set_access_token(const std::string& value) {
  
  _impl_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* SignInUserResponse::_internal_mutable_access_token() {
  
  return _impl_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* SignInUserResponse::release_access_token() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignInUserResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void SignInUserResponse::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  _impl_.access_token_.SetAllocated(access_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_token_.IsDefault()) {
    _impl_.access_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignInUserResponse.access_token)
}

// string refresh_token = 3 [json_name = "refreshToken"];
inline void SignInUserResponse::clear_refresh_token() {
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& SignInUserResponse::refresh_token() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.SignInUserResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignInUserResponse::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.refresh_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.SignInUserResponse.refresh_token)
}
inline std::string* SignInUserResponse::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.SignInUserResponse.refresh_token)
  return _s;
}
inline const std::string& SignInUserResponse::_internal_refresh_token() const {
  return _impl_.refresh_token_.Get();
}
inline void SignInUserResponse::_internal_set_refresh_token(const std::string& value) {
  
  _impl_.refresh_token_.Set(value, GetArenaForAllocation());
}
inline std::string* SignInUserResponse::_internal_mutable_refresh_token() {
  
  return _impl_.refresh_token_.Mutable(GetArenaForAllocation());
}
inline std::string* SignInUserResponse::release_refresh_token() {
  // @@protoc_insertion_point(field_release:resume.user.v1.SignInUserResponse.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void SignInUserResponse::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    
  } else {
    
  }
  _impl_.refresh_token_.SetAllocated(refresh_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.refresh_token_.IsDefault()) {
    _impl_.refresh_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.SignInUserResponse.refresh_token)
}

// -------------------------------------------------------------------

// VerifyEmailRequest

// string verificationCode = 1 [json_name = "verificationCode"];
inline void VerifyEmailRequest::clear_verificationcode() {
  _impl_.verificationcode_.ClearToEmpty();
}
inline const std::string& VerifyEmailRequest::verificationcode() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.VerifyEmailRequest.verificationCode)
  return _internal_verificationcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyEmailRequest::set_verificationcode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verificationcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.VerifyEmailRequest.verificationCode)
}
inline std::string* VerifyEmailRequest::mutable_verificationcode() {
  std::string* _s = _internal_mutable_verificationcode();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.VerifyEmailRequest.verificationCode)
  return _s;
}
inline const std::string& VerifyEmailRequest::_internal_verificationcode() const {
  return _impl_.verificationcode_.Get();
}
inline void VerifyEmailRequest::_internal_set_verificationcode(const std::string& value) {
  
  _impl_.verificationcode_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyEmailRequest::_internal_mutable_verificationcode() {
  
  return _impl_.verificationcode_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyEmailRequest::release_verificationcode() {
  // @@protoc_insertion_point(field_release:resume.user.v1.VerifyEmailRequest.verificationCode)
  return _impl_.verificationcode_.Release();
}
inline void VerifyEmailRequest::set_allocated_verificationcode(std::string* verificationcode) {
  if (verificationcode != nullptr) {
    
  } else {
    
  }
  _impl_.verificationcode_.SetAllocated(verificationcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verificationcode_.IsDefault()) {
    _impl_.verificationcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.VerifyEmailRequest.verificationCode)
}

// -------------------------------------------------------------------

// GetMeRequest

// string Id = 1 [json_name = "Id"];
inline void GetMeRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetMeRequest::id() const {
  // @@protoc_insertion_point(field_get:resume.user.v1.GetMeRequest.Id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMeRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:resume.user.v1.GetMeRequest.Id)
}
inline std::string* GetMeRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:resume.user.v1.GetMeRequest.Id)
  return _s;
}
inline const std::string& GetMeRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetMeRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMeRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMeRequest::release_id() {
  // @@protoc_insertion_point(field_release:resume.user.v1.GetMeRequest.Id)
  return _impl_.id_.Release();
}
inline void GetMeRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:resume.user.v1.GetMeRequest.Id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace user
}  // namespace resume

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::resume::user::v1::User_role> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::resume::user::v1::User_role>() {
  return ::resume::user::v1::User_role_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_2fv1_2fuser_2eproto
